1️⃣ Git 담당자의 핵심 역할

레포지토리 생성 및 초기 설정

GitHub, GitLab, Bitbucket 등 팀에서 사용할 플랫폼 결정

프로젝트 초기 구조(commit) 올리기

.gitignore 설정 (Node.js → node_modules, Vue 빌드 산출물 제외)

README.md 작성 (프로젝트 목적, 환경설정, 팀원 목록 등)

팀 규칙 정의

브랜치 전략 결정

예: main(배포용), develop(통합용), feature/기능명(개별 기능 개발)

커밋 메시지 규칙

예: [FE], [BE] 접두사 사용, 기능 단위로 의미 있게 작성

PR(Pull Request) 규칙

코드 리뷰 필수, 최소 1명 이상 승인 후 머지

협업 툴과 연동

GitHub Issues, Project Board, Slack/Notion 연동

팀원 교육 및 지원

Git clone, pull, push, branch 생성, PR 등 기본 워크플로우 공유

충돌(conflict) 해결 방법 안내

CI/CD 및 자동화(Optional)

GitHub Actions 같은 툴로 자동 빌드/테스트 설정

초반엔 필수는 아니지만 나중에 배포를 쉽게 함

2️⃣ 프로젝트 시작 단계 (실제 진행)

레포지토리 생성

git init
git remote add origin <레포지토리_URL>


프로젝트 초기 구조 커밋

git add .
git commit -m "Initial commit: 프로젝트 기본 구조"
git push -u origin main


브랜치 전략 적용

git checkout -b develop
git push -u origin develop


팀원들에게 가이드 전달

PR 시 누구에게 리뷰 요청

branch 이름 규칙, 커밋 메시지 예시 등 문서화

첫 번째 기능 개발 시작

팀원 각자 feature/기능명 브랜치 생성 후 작업

완료 시 develop 브랜치로 PR

💡 Tip:

Git 담당자가 가장 먼저 해야 하는 일은 팀원과 함께 브랜치 전략과 규칙을 명확히 합의하는 것.

Git은 ‘코드 올리는 도구’가 아니라 팀 협업 규칙을 지켜주는 도구라고 생각하면 편해요.

1️⃣ Git 담당자가 해야 할 일, 초보 버전
1. 레포지토리 만들기

GitHub(또는 GitLab 등)에 접속 → 새 레포지토리 생성

이름과 설명 입력

.gitignore를 Node.js용으로 선택 → node_modules, 빌드 파일 제외

README.md 체크해서 프로젝트 기본 문서 생성

2. 프로젝트 올리기 (초기 커밋)
git clone <레포지토리_URL>   # 팀원들이 가져올 수 있는 원본 만들기
cd <프로젝트폴더>
git add .
git commit -m "Initial commit: 프로젝트 기본 구조"
git push -u origin main

3. 팀 브랜치 규칙 만들기 (초보 친화 버전)

main → 배포용, 안정된 버전만

develop → 통합용, 팀원들이 각자 기능 개발 후 합치는 브랜치

feature/기능이름 → 팀원이 개인 작업하는 브랜치

예시:

main
develop
feature/login
feature/admin-page

4. 팀원용 간단 사용법

브랜치 만들기

git checkout -b feature/기능이름


작업 후 커밋

git add .
git commit -m "[FE] 로그인 페이지 구현"


원격 develop 브랜치에 push

git push origin feature/기능이름


GitHub에서 PR(Pull Request) → develop에 병합

5. Git 담당자 역할 정리 (초보용)

레포지토리 생성 + 초기 구조 올리기

브랜치 전략 문서로 정리해서 팀 공유

팀원들이 Git 처음 써도 혼란 없게 안내

충돌 발생 시 간단히 해결 방법 안내

PR 승인 및 develop/main 머지 관리

💡 Tip: 초반엔 너무 복잡하게 하지 말고

main → 배포용

develop → 통합용

feature/* → 개인 기능
이 3개 브랜치만 명확히 지키면 충분합니다.

1️⃣ 상황 이해

팀원 모두 app.js를 수정하고 있어요.

각자 로컬에서 코드를 작성 후 push하면 서로의 변경 사항이 충돌할 수 있어요.

Git은 **“누가 먼저 올렸는지”**를 기준으로 머지를 시도하고, 충돌이 있으면 사람이 해결해야 해요.

2️⃣ Git이 처리하는 방식 (간단하게)

팀원 A가 feature 브랜치에서 app.js 수정 후 push
→ GitHub에 저장

팀원 B가 같은 파일 app.js 수정 후 push 시도
→ GitHub가 “충돌 가능성이 있어요”라고 알려줌

팀원 B는 먼저 develop 브랜치 최신 버전 pull

git checkout develop
git pull origin develop
git checkout feature/B
git merge develop


이때 Git이 자동으로 합칠 수 있으면 자동 merge

같은 라인을 다른 내용으로 수정했으면 충돌(conflict) 발생 → 수동으로 해결

충돌 해결 후

git add app.js
git commit -m "Merge develop into feature/B, conflict resolved"
git push origin feature/B


이제 팀원 B의 PR을 develop에 머지 가능

3️⃣ 안전하게 팀원들이 작업하는 방법

작업은 항상 개인 브랜치에서

feature/login, feature/admin-page 등

main이나 develop에 바로 push X

작은 단위로 자주 커밋 & push

한 파일 한 기능 정도 단위가 안전

큰 단위로 한 번에 push하면 충돌 위험 ↑

Pull로 최신 버전 반영

feature 브랜치 작업 시작 전 develop 최신 pull

주기적으로 develop merge

PR(Pull Request) 활용

develop에 합치기 전에 코드 리뷰

충돌 발생 시 팀원이 해결 방법 확인

🔹 예시 시나리오

app.js 기본 구조:

const express = require('express');
const app = express();

// 팀원 A 기능
// 팀원 B 기능

app.listen(3000, () => console.log("Server started"));


팀원 A: 로그인 라우터 추가

팀원 B: 장애인 대기자 목록 라우터 추가

Git은 같은 파일 다른 줄이면 자동 merge 가능
같은 줄 수정이면 충돌 → 직접 코드를 보고 합쳐야 함

💡 요약:

각자 브랜치에서 작업 → 충돌 최소화

push 전 항상 최신 develop pull → 안전

충돌 발생 시 Git이 알려주면 직접 해결

작은 단위 커밋 & PR → 팀원 간 코드 합치기 원활

1️⃣ 임시 Git 담당자가 레포지토리 만들기

GitHub 계정으로 로그인 → 새 레포지토리 생성

이름: 예) disabled-waiting-app

.gitignore → Node 선택

README 체크

로컬에서 초기 프로젝트 올리기

git clone <레포지토리_URL>
cd disabled-waiting-app
git add .
git commit -m "Initial commit: 프로젝트 구조"
git push -u origin main


브랜치 전략 설정

git checkout -b develop
git push -u origin develop

2️⃣ 팀원 초대

GitHub 레포지토리 → Settings → Collaborators

팀원 계정 이메일/아이디 입력 → 초대

원래 Git 담당자도 초대

3️⃣ 원래 Git 담당자에게 소유권 이전

레포지토리 → Settings → General → Transfer ownership

새로운 소유자(Git 담당자) GitHub 아이디 입력

확인 → 소유권 이전 완료

이 과정 후에도 기존 임시 담당자는 Collaborator로 남아서 관리 가능

🔹 팁

임시로 만들 때도 브랜치 전략과 README를 먼저 만들어 두면, 원래 담당자가 받았을 때 바로 팀원과 협업 가능

develop 브랜치, .gitignore, PR 규칙 문서화까지 해두면 인수인계가 훨씬 부드러워요

질문 : 소유권을 이전하게되면 git에 접근하기 위한 토큰은 어떻게 되는거야?

좋아요, 이건 중요한 부분이에요. GitHub에서 레포지토리 소유권을 이전하면 토큰과 접근 권한이 어떻게 바뀌는지 단계별로 정리해드릴게요.

1️⃣ 소유권 이전 전

임시 담당자가 레포지토리를 만들고 push/pull을 위해 Personal Access Token(PAT) 또는 계정 비밀번호(예전 방식)를 사용합니다.

팀원들은 Collaborator로 초대되어 자신의 GitHub 계정으로 push/pull 가능.

2️⃣ 소유권 이전 과정

레포지토리 → Settings → General → Transfer ownership

새 소유자(Git 담당자) GitHub 계정 입력 → 확인

소유권이 이전되면 임시 담당자는 여전히 Collaborator로 남을 수 있음

3️⃣ 소유권 이전 후 토큰/접근 권한

새 소유자

전체 권한 소유 (Admin) → 레포지토리 설정, 브랜치 보호, 팀 관리 가능

본인 계정으로 push/pull → 기존 토큰 사용 가능

임시 담당자

이전 과정에서 소유자에서 내려오지만, Collaborator로 남아있으면 그대로 push/pull 가능

기존 토큰 그대로 사용 가능, 단 Admin 권한은 없음

필요시 소유자가 접근 권한 조정 가능 (예: 쓰기 권한 제거)

팀원

토큰은 그대로 사용 가능

권한은 소유자가 관리 (읽기/쓰기/Admin 등)

💡 요약:

토큰 자체는 계정 단위라서 소유권 이전 때문에 새로 발급할 필요 없음

단, 레포지토리 설정을 바꾸거나 Admin 권한을 갖고 싶다면 새 소유자가 자신의 계정으로 토큰 발급 필요

질문 : 그렇다면 git의 branch가 main(배포용), develop(개인 개발한 것을 합치는 용도), 1,2,3,4(4명의 팀원이 각자 개발한 것을 올리는 branch)로 나누면 1,2,3,4 branch에 올릴 때는 각자 토큰을 이용해서 올리고 develop라는 branch에서는 git 담당자가 merge를 하는 방식인거야?

맞아요, 거의 정확하게 이해하셨어요! 😄 조금 더 정확하게 흐름을 정리하면 이렇게 됩니다.

1️⃣ 브랜치 구조
main      → 배포용, 안정된 버전
develop   → 개인 기능 브랜치를 모아 통합하는 용도
1,2,3,4  → 팀원 개인 개발 브랜치 (각자 이름 또는 번호)

2️⃣ 각 브랜치 역할과 작업 방식
브랜치	누가 작업	push/merge 방식	특징
1,2,3,4	각 팀원	본인 계정의 토큰으로 push	개인 기능 개발, 자유롭게 커밋
develop	Git 담당자(또는 merge 담당자)	PR(Pull Request) 승인 후 merge	팀원 브랜치 기능을 통합, 코드 리뷰 후 병합
main	Git 담당자	안정된 develop을 merge	배포용, 항상 안정적이어야 함
3️⃣ 실제 흐름 예시

팀원 A는 1 브랜치에서 로그인 기능 개발

git checkout -b feature/login  # 로컬 브랜치
git add .
git commit -m "[FE] 로그인 기능 구현"
git push origin 1


팀원 B는 2 브랜치에서 장애인 대기자 목록 개발

git push origin 2


Git 담당자는 주기적으로 develop 브랜치에서 각 팀원 브랜치를 병합

git checkout develop
git pull origin develop
git merge 1   # 팀원 A 기능 통합
git merge 2   # 팀원 B 기능 통합
git push origin develop


충돌 발생 시

Git이 알려줌 → merge 담당자 또는 팀원과 함께 충돌 해결

해결 후 commit → push

배포 시

develop이 안정적이면 main에 merge → 배포용

4️⃣ 토큰 사용 관련

팀원 1,2,3,4 → 각자 GitHub 토큰 사용해서 자신의 브랜치 push 가능

develop, main merge → merge 담당자가 본인 토큰 사용

토큰은 브랜치 소유와 관계 없고, 계정 권한이 충분하면 merge 가능

따라서 merge 담당자만 Admin 권한이 필요

💡 Tip:

팀원 브랜치는 혼자 push → 다른 팀원과 충돌 적음

merge 담당자가 develop에서 통합 → 코드 리뷰와 충돌 해결 담당

develop 브랜치를 main에 merge할 때는 꼭 안정성 확인